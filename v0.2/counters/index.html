<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Counting Â· PAPI.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PAPI.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../events/">Events</a></li><li><a class="tocitem" href="../eventsets/">Event Sets</a></li><li class="is-active"><a class="tocitem" href>Counting</a><ul class="internal"><li><a class="tocitem" href="#Measuring-Performance"><span>Measuring Performance</span></a></li><li><a class="tocitem" href="#PAPI-interface"><span>PAPI interface</span></a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Counting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Counting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tomhaber/PAPI.jl/blob/master/docs/src/counters.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Counting-Events"><a class="docs-heading-anchor" href="#Counting-Events">Counting Events</a><a id="Counting-Events-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-Events" title="Permalink"></a></h1><p><code>PAPI</code> provides the ability to start, stop, read and accumulate the counters for a specified list of events. <code>PAPI.jl</code> exposes this functionality (See <a href="#papi-interface">counting</a>), but builds more user-friendly primitives on top of this.</p><p><code>PAPI.jl</code> stores count values using the <code>Counts</code> type.</p><h2 id="Measuring-Performance"><a class="docs-heading-anchor" href="#Measuring-Performance">Measuring Performance</a><a id="Measuring-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-Performance" title="Permalink"></a></h2><p><code>PAPI,jl</code> provides two ways of measuring performance counters:</p><ul><li>Quick, one shot <code>profile</code></li><li>Extensive <code>sample</code> based</li></ul><h3 id="Profile"><a class="docs-heading-anchor" href="#Profile">Profile</a><a id="Profile-1"></a><a class="docs-heading-anchor-permalink" href="#Profile" title="Permalink"></a></h3><p><code>profile</code> and <code>@profile</code> can be used to quickly measure some performance counts on a function or expression. Since the function is only executed once, these counts should be taken with a grain of salt as they can be riddled with noise especially for short running functions.</p><article class="docstring"><header><a class="docstring-binding" id="PAPI.profile" href="#PAPI.profile"><code>PAPI.profile</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">profile(f::Function, events::Vector{Event}; gcfirst::Bool=true, warmup::Int64=0)</code></pre><p>Execute the function <code>f</code> once while counting specific <code>events</code>.</p><p><strong>Arguments</strong>:</p><pre><code class="language-none">-`f`: the function to profile
-`events`: the events to count
-`gcfirst`: run the gc several times before the execution to reduce gc noise
-`warmup`: number of times to run the function prior to counting</code></pre><p><strong>Return values</strong>:</p><p><code>EventValues</code> containing the events, counts and runtime collected</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/sampling.jl#L41-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PAPI.@profile" href="#PAPI.@profile"><code>PAPI.@profile</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">profile(ex, args...)</code></pre><p>Convience macro for profiling an expression. Events can be specified as a first argument, otherwise the default events <code>[BR_INS, BR_MSP, TOT_INS, TOT_CYC]</code> are counted</p><p>Arguments and return values are similar to <a href="#PAPI.profile"><code>profile</code></a></p><p><strong>Example</strong>:</p><pre><code class="language-julia">@profile f(x, y, z) # sampling default events
@profile [PAPI.TOT_INS, PAPI.DP_OPS, native_event] f(x, y, z) gcfirst=false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/sampling.jl#L177-L190">source</a></section></article><p>The resulting <code>EventValues</code> contain the events and counts collected and when printed a nice summary is generated with additional information.</p><h3 id="Sample"><a class="docs-heading-anchor" href="#Sample">Sample</a><a id="Sample-1"></a><a class="docs-heading-anchor-permalink" href="#Sample" title="Permalink"></a></h3><p>Contrary to <code>profile</code>, <code>sample</code> and <code>@sample</code> perform multiple executions. The resulting samples can be used to investigate the distributions of the counts and to perform various statistical tests.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You should be careful when making decisions on performance based on single or aggregate values (such as <code>mean</code>, <code>minimum</code>, <code>median</code>) as well as &quot;eyeball&quot; statistics. Statistical tests such as a <a href="https://en.wikipedia.org/wiki/Student%27s_t-test">t-test</a>, <a href="https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">wilcoxon</a> can be used.</p><p>Personally, I&#39;m also wary towards any asymptotical tests putting strong assumptions on the distributions. For example, performance numbers (even runtime) are not always normal distributed: the process is usually skewed towards one side. I tend to use the samples themselves as well as their quantiles.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PAPI.sample" href="#PAPI.sample"><code>PAPI.sample</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample(f::Function, events::Vector{Event}; max_secs::Float64=5, max_epochs::Int64=1000, gcsample::Bool=false, warmup::Int64=1)</code></pre><p>Execute the function <code>f</code> several times, each time counting specific <code>events</code>. Sampling continues until either the maximum number of samples <code>max_epochs</code> are collected or the runtime budget <code>max_secs</code> is exceeded.</p><p><strong>Arguments</strong>:</p><pre><code class="language-none">-`f`: the function to profile
-`events`: the events to count
-`max_secs`: maximum number of seconds to sample for
-`gcsample`: run the gc several times before the execution to reduce gc noise
-`warmup`: number of times to run the function prior to counting</code></pre><p><strong>Return values</strong>:</p><p><code>EventStats</code> containing the events, counts and runtime collected</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/sampling.jl#L117-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PAPI.@sample" href="#PAPI.@sample"><code>PAPI.@sample</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">sample(ex, args...)</code></pre><p>Convience macro for sampling an expression. Events can be specified as a first argument, otherwise the default events <code>[BR_INS, BR_MSP, TOT_INS, TOT_CYC]</code> are counted</p><p>Arguments and return values are similar to <a href="#PAPI.sample"><code>sample</code></a></p><p><strong>Example</strong>:</p><pre><code class="language-julia">@sample f(x, y, z) # sampling default events
@sample [PAPI.TOT_INS, PAPI.DP_OPS, native_event] f(x, y, z) max_secs=1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/sampling.jl#L198-L211">source</a></section></article><p>The resulting <code>EventStats</code> contain the events and all counts collected and when printed a nice summary is generated with additional statistics. The additional statistics are computed using the <code>mean</code> and are mostly intended as information to guide the optimization process.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>As an example consider the following function</p><pre><code class="language-julia">function mysum(X::AbstractArray)
    s = zero(eltype(X))
    for x in X
        s += x
    end
    s
end</code></pre><p>Next, we&#39;ll create an array of double precision values and produce a profile using the default events</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>warmup</code> is set to 1, to force compilation prior to measurement</p></div></div><pre><code class="language-julia">X = rand(10000)
@profile mysum(X) warmup=1</code></pre><pre class="documenter-example-output">EventValues:
  BR_INS = 10186 # 25.0% of all instructions # 663.0 M/sec 
  BR_MSP = 27 # 0.0%[m of all branches
  TOT_INS = 40965 # 0.731 insn per cycle
  TOT_CYC = 56039 # 3.645 Ghz # 1.368 cycles per insn
  runtime = 15374 nsecs</pre><p>Since the number of elements added was 10000, you can note it take roughly 4 instructions per element. Out of which one is a branch instruction, corresponding to the termination test of the loop. We also expect the data needs to be loaded in every iteration, something we can verify by additionally measuring the number of loads using the preset <code>PAPI.LD_INS</code>.</p><pre><code class="language-julia">@profile [PAPI.TOT_INS, PAPI.TOT_CYC, PAPI.LD_INS, PAPI.BR_INS] mysum(X)</code></pre><pre class="documenter-example-output">EventValues:
  TOT_INS = 40965 # 0.818 insn per cycle
  TOT_CYC = 50051 # 3.4 Ghz # 1.222 cycles per insn
  LD_INS = 10298 # 25.0% of all instructions # 700.0 M/sec 
  BR_INS = 10186 # 25.0% of all instructions # 692.0 M/sec 
  runtime = 14719 nsecs</pre><p>Indeed, in addition to the branch instruction there is a load in every iteration as well. Generally, you would expect a load, a branch, an addition and a counter increment in every iteration, and this data seems to confirm this. However modern processors are capable of loading and multiplying multiple data items at the same time. The <code>@simd</code> macro might be useful here.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@simd</code> instructs the compiler that it is safe to execute the iterations in arbitrary and overlapping order. This also means that we are fine with any floating-point errors introduced by this reordering of operations.</p></div></div><pre><code class="language-julia">function mysum2(X::AbstractArray)
    s = zero(eltype(X))
    @simd for x in X
        s += x
    end
    s
end

@profile [PAPI.TOT_INS, PAPI.TOT_CYC, PAPI.LD_INS, PAPI.BR_INS] mysum2(X) warmup=1</code></pre><pre class="documenter-example-output">EventValues:
  TOT_INS = 5362 # 0.24 insn per cycle
  TOT_CYC = 22348 # 4.657 Ghz # 4.168 cycles per insn
  LD_INS = 2801 # 52.0% of all instructions # 584.0 M/sec 
  BR_INS = 814 # 15.0% of all instructions # 170.0 M/sec 
  runtime = 4799 nsecs</pre><p>Note the reduction in the number of cycles, instructions, branches, loads and runtime. From these measurements, one could assume the addition of <code>@simd</code> has a positive effect. However, it would be better if we compute more samples and perform a statistical test to confirm that the effect is significant.</p><p>Finally, let&#39;s look at the number of floating-point operations and vectorized floating-point operations.</p><pre><code class="language-julia">@profile [PAPI.TOT_INS, PAPI.DP_OPS, PAPI.VEC_DP] mysum(X)</code></pre><pre class="documenter-example-output">EventValues:
  TOT_INS = 40971
  DP_OPS = 10000 # 24.0% of all instructions # 1.0x vectorized
  VEC_DP = 10000 # 24.0% of all instructions
  runtime = 14192 nsecs</pre><pre><code class="language-julia">@profile [PAPI.TOT_INS, PAPI.DP_OPS, PAPI.VEC_DP] mysum2(X)</code></pre><pre class="documenter-example-output">EventValues:
  TOT_INS = 5368
  DP_OPS = 10015 # 187.0% of all instructions # 3.998x vectorized
  VEC_DP = 2505 # 47.0% of all instructions
  runtime = 6139 nsecs</pre><p>Both functions perform the same number of additions (<span>$\approx 1$</span> per element), but <code>mysum</code> is able to vectorize those operations (performing almost 4 additions at the same time). Looking back at the earlier comparison, we can also see the number of loads has decreased by a factor of 4, indicating that the loop now loads roughly four elements simultaneously. The number of branches had decreased even more. Investigation of <code>@code_native mysum2(X)</code> indeed also indicated that the compiler does loop unrolling in addition to vectorization.</p><p>Let&#39;s now collect multiple samples in order to draw our final conclusion:</p><pre><code class="language-julia">stats = @sample mysum(X) # original version
stats2 = @sample mysum2(X) # optimized version</code></pre><pre class="documenter-example-output">EventStats:
  BR_INS = [781, 781, 781, 781, 781, 781, 781, 781, 781, 781  â€¦  781, 781, 781, 781, 781, 781, 781, 781, 781, 781] # 15.0% of all instructions # 804.0 M/sec 
  BR_MSP = [16, 5, 2, 2, 3, 2, 2, 3, 2, 2  â€¦  2, 2, 2, 2, 2, 2, 2, 2, 3, 3] # 0.0%[m of all branches
  TOT_INS = [5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043  â€¦  5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043, 5043] # 1.4 insn per cycle
  TOT_CYC = [9569, 3965, 3683, 3588, 3675, 3525, 3533, 3646, 3519, 3612  â€¦  3605, 3585, 3565, 3659, 3562, 3568, 3563, 3591, 3734, 3694] # 3.707 Ghz # 0.716 cycles per insn
  runtime = [2639, 1123, 1033, 1007, 1034, 982, 970, 1020, 985, 1010  â€¦  924, 920, 908, 940, 915, 917, 909, 919, 958, 951] nsecs</pre><p>1000 samples were collected for both version for the default events as well as the runtimes. A decision can for example be made using a <code>wilcoxon</code> (or <code>mann-whitney U</code>) test. This tests whether the two sets of samples come from the same underlying distribution.</p><pre><code class="language-julia">using HypothesisTests
x = stats.time
y = stats2.time
MannWhitneyUTest(x,y)</code></pre><pre class="documenter-example-output">Approximate Mann-Whitney U test
-------------------------------
Population details:
    parameter of interest:   Location parameter (pseudomedian)
    value under h_0:         0
    point estimate:          10540.5

Test summary:
    outcome with 95% confidence: reject h_0
    two-sided p-value:           &lt;1e-99

Details:
    number of observations in each group: [1000, 1000]
    Mann-Whitney-U statistic:             999011.0
    rank sums:                            [1.49951e6, 501489.0]
    adjustment for ties:                  347856.0
    normal approximation (Î¼, Ïƒ):          (499011.0, 12912.9)
</pre><p>Rejection of the null-hypothesis indicates the underlying distributions are different and the changes have some significant effect (in this case a positive effect).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Alternatively, a student t-test could be used to perform a similar test. However, this test assumes normally distributed samples. Plotting a histogram of the samples clearly indicates this is not the case.</p></div></div><p>Using a <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">Monte-Carlo estimator</a>, the expected speedup can be computed as well as 95% uncertainty intervals.</p><pre><code class="language-julia">using Statistics
println(&quot;expected speedup = &quot;, mean(x ./ y&#39;))
println(&quot;95% of the time, the speedup lies within &quot;, quantile(vec(x ./ y&#39;), [.025, 0.975]))</code></pre><pre class="documenter-example-output">expected speedup = 12.126390102115225
95% of the time, the speedup lies within [11.037392138063279, 13.673558215451578]</pre><h2 id="PAPI-interface"><a class="docs-heading-anchor" href="#PAPI-interface">PAPI interface</a><a id="PAPI-interface-1"></a><a class="docs-heading-anchor-permalink" href="#PAPI-interface" title="Permalink"></a></h2><p>Only a number of events can be counted at the same time, <code>num_counters</code> returns the number of hardware counters available on the system.</p><article class="docstring"><header><a class="docstring-binding" id="PAPI.num_counters" href="#PAPI.num_counters"><code>PAPI.num_counters</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Get the number of hardware counters available on the system</p><p><code>PAPI.num_counters()</code> initializes the PAPI library if necessary.</p><p><code>PAPI_num_counters()</code>` returns the number of hardware counters available on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/PAPI.jl#L30-L36">source</a></section></article><p>After selecting a number of events to count, the counting process can be started and stopped using <code>start_counters</code> and <code>stop_counters</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is the userâ€™s responsibility to choose events that can be counted simultaneously by reading the vendorâ€™s documentation.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="PAPI.start_counters" href="#PAPI.start_counters"><code>PAPI.start_counters</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">start_counters(events)</code></pre><p>Start counting hardware events.  This function cannot be called if the counters have already been started.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/counters.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PAPI.stop_counters" href="#PAPI.stop_counters"><code>PAPI.stop_counters</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stop_counters(evtset::EventSet)</code></pre><p>Stop counters and returns counts The counters must have been started by a previous call to <code>start_counters</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/counters.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PAPI.stop_counters!" href="#PAPI.stop_counters!"><code>PAPI.stop_counters!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stop_counters!(evtset::EventSet, values::Vector{Counts})</code></pre><p>Stop counters and return current counts. The counters must have been started by a previous call to <code>start_counters</code></p><p>The user must provide a vector of the correct size (equal to the number of events)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/counters.jl#L67-L74">source</a></section></article><pre><code class="language-julia">events = Event[PAPI.TOT_INS, PAPI.DP_OPS]
evtset = start_counters(events)
computation()
values = stop_counters(evtset)</code></pre><pre class="documenter-example-output">2-element Array{Int64,1}:
 74986127
    10001</pre><p>During the counting process, the current counts can be queried and accumulated using <code>read_counters!</code> and <code>accum_counters!</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PAPI.read_counters!" href="#PAPI.read_counters!"><code>PAPI.read_counters!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_counters!(evtset::EventSet, values::Vector{Counts})</code></pre><p>Read and reset counters. <code>read_counters!</code> copies the event counters into values. The counters are reset and left running after the call.</p><p>The user must provide a vector of the correct size (equal to the number of events)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/counters.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PAPI.accum_counters!" href="#PAPI.accum_counters!"><code>PAPI.accum_counters!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">accum_counters!(evtset::EventSet, values::Vector{Counts})</code></pre><p>Accumulate and reset counters. <code>accum_counters!</code> accumulates the event counters into values. The counters are reset and left running after the call.</p><p>The user must provide a vector of the correct size (equal to the number of events)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tomhaber/PAPI.jl/blob/ea02f19474e0e93cead8bee9e563b6d7e48d32ef/src/counters.jl#L54-L61">source</a></section></article><pre><code class="language-julia">events = Event[PAPI.DP_OPS]
values = Vector{Counts}(undef, length(events))
evtset = start_counters(events)
computation(100) # perform 100 double precision operations
read_counters!(evtset, values)
println(values[1], &quot; roughly equals 100&quot;)

computation(100) # perform 100 double precision operations
accum_counters!(evtset, values)
println(values[1], &quot; roughly equals 200&quot;)

values[1] = -100
computation(100) # perform 100 double precision operations
accum_counters!(evtset, values)
println(values[1], &quot; roughly equals 0&quot;)
stop_counters(evtset); nothing</code></pre><pre class="documenter-example-output">100 roughly equals 100
200 roughly equals 200
0 roughly equals 0</pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../eventsets/">Â« Event Sets</a><a class="docs-footer-nextpage" href="../public/">Public Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 16 November 2020 20:02">Monday 16 November 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
